\documentclass{scrartcl}

\usepackage{fancyvrb}
\usepackage{appendix}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[style=french]{csquotes}
\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xifthen}
\usepackage{hyperref}
\usepackage{caption}

% pour du code verbatim
\lstnewenvironment{java}{\lstset{language=Java,basicstyle=\small}}{}
\lstnewenvironment{shellcmds}{\lstset{language=Java,basicstyle=\small}}{}

% abréviations latine
\newcommand{\etal}{\textit{et al.}\@\xspace}
\newcommand{\ie}{\textit{i.e.}\@\xspace}
\newcommand{\eg}{\textit{e.g.}\@\xspace}

% pour que make/latexmk genère les fichiers manquantes
\newcommand{\makeincudegraphics}[2][]{%
    \IfFileExists{#2}{\includegraphics[#1]{#2}}{\typeout{No file #2.}}}

% pour avoir \verb dans les notes de bas de page
\VerbatimFootnotes

\title{Rapport SAE}
\author{BA GUBAIR Emad \and BARTIER Tom \and MARÇAIS André \and ROBLIN Yann}

\begin{document}

\maketitle{}

\begin{abstract}
    Ce document présente le projet SAE du Master 1 Informatique et Mathématiques 2024-2025
    de l’Université de Toulon. Il est encadré par Julien Seinturier et Emmanuel Bruno, professeurs à l’Université de Toulon.
    Le projet consiste à développer un simulateur de drone sous-marin en Java. Pour ce faire, les étudiants
    ont mobilisé les connaissances acquises tout au long de l’année, notamment en programmation, gestion de projet et
    modélisation.
\end{abstract}

\tableofcontents

\section{Problématique}
Les fonds marins sont un milieu que nous connaissons peu et qui est difficile d'accès.
Afin de mieux les étudier, nous pouvons utiliser des drones sous-marins pilotés à distance
pour mener différentes missions comme la prise de photos ou la collecte de données.
Cependant, les drones sous-marins sont coûteux et demandent un minimum d'entraînement au pilotage.
Pour des missions très délicates, on pourrait imaginer qu'une IA puisse réaliser ces missions, mais cela
nécessite de pouvoir entraîner l'IA, notamment dans un environnement virtuel. L'idée de faire un simulateur
est donc vraiment pertinente car il permettrait d'entraîner à la fois des pilotes humains et des IA.

\section{Description générale et Modélisation}
ArduPilot est une interface de pilotage de drone open source utilisée par de nombreux passionnés et professionnels
pour piloter tous types de drones (aériens, sous-marins ou terrestres). L'objectif de ce projet est de développer un simulateur
de drone sous-marin que l'on pourrait connecter à Ardupilot un peu comme si c'était un vrai drone afin que des pilotes ayant de l'expérience
avec Ardupilot puissent passer du drone virtuel au drone réel sans avoir à changer leurs habitudes. Afin d'aller un peu plus loin et de permettre
une certaine flexibilité, le simulateur a été conçu pour pouvoir être facilement adapté à n'importe quelle interface de pilotage.
\\

Tout d'abord, on peut identifier quatre acteurs principaux :
\begin{itemize}
    \item Le pilote, qui pilote le drone virtuel.
    \item Le maître du jeu (MDJ), qui gère les drones virtuels et peut modifier leur environnement.
    \item L'observateur, qui peut observer l'environnement de la simulation
    \item L'administrateur, qui gère les utilisateurs
\end{itemize}

Pour en savoir plus sur les acteurs, leur rôle dans le système et les différentes fonctionnalités qui leur sont accessibles, vous pouvez consulter le diagramme de cas d'usage (voir figure \ref{fig:uc}).
Le simulateur a été écrit en Java, il contient plusieurs composantes (voir figures \ref{fig:fwclient} et \ref{fig:fwserveur}).
La simulation tourne autour d'un serveur REST appelé ici "Manager".
Le Manager gère principalement l’authentification des utilisateurs, la création des drones virtuels, le lancement du serveur de simulation,
ainsi que l’ajout ou la suppression en temps réel d’événements dans l’environnement. À terme, il permettra également l’ajout de nouveaux drones virtuels en temps réel.
Les utilisateurs disposent d'un logiciel avec une interface graphique appelé ici "launcher" qui leur permet de se connecter et d'interagir avec la simulation
en fonction de leur rôle. Concernant les pilotes, le launcher est aussi responsable du lancement des différents composants de l'interface de pilotage.
\\
Pour comprendre comment les différents composants interagissent entre eux, vous pouvez consulter le diagramme de séquence
de l'UC "Le pilote se connecte au simulateur" (voir figure \ref{fig:conn_pilote_seq}).
Un petit détail concernant ce diagramme de séquence : ce n'est en effet pas très logique que ce soit le serveur de la simulation qui ouvre la connexion à Ardusub, il faudrait en toute logique
que ce soit l'inverse car Ardupilot est censé être un client qui se connecte à un serveur dans notre philosophie et pas l'inverse, mais
nous avons dû faire ainsi pour des raisons techniques, voir la section \ref{sec:problemes}.\\
% TODO: Parler de ça dans les problèmes / perspectives (André/Yann)

Nous avons aussi réalisé un diagramme de classes (voir figure \ref{fig:classes}) qui permet de visualiser certains aspects du projet. On peut voir notamment
que les drones possèdent des modules qui peuvent être des capteurs ou des systèmes (bras robotisé par exemple). Si on veut rajouter un capteur à un drone, il suffit de
créer un nouvel objet de la classe Capteur, ceci permet une certaine modularité. Concernant les contrôleurs, afin que notre simulateur puisse
être utilisé avec n'importe quelle interface de pilotage, nous avons défini une interface Controler que chaque contrôleur doit implémenter. Ainsi, si on veut
rajouter un nouveau contrôleur pour une nouvelle interface de pilotage, il suffit de créer une nouvelle classe qui implémente l'interface ControleurDrone. Dans notre cas
nous l'avons implémentée pour ArduSub, mais il est possible de l'implémenter pour n'importe quelle autre interface de pilotage.


\begin{figure}[p]
    \makeincudegraphics[width=1.1\textwidth]{ardupilot_server_components.png}
    \caption{Diagramme de composantes (rendu côté serveur)}
    \label{fig:fwserveur}
\end{figure}

\begin{figure}[p]
    \makeincudegraphics[width=1.1\textwidth]{ardupilot_client_components.png}
    \caption{Diagramme de composantes (rendu côté client)}
    \label{fig:fwclient}
\end{figure}

\begin{figure}[p]
    \makeincudegraphics[width=\textwidth]{simulateur_uc.png}
    \caption{Diagramme de cas d'usage}
    \label{fig:uc}
\end{figure}

\begin{figure}[p]
    \makeincudegraphics[width=\textwidth]{conn_pilote_seq.png}
    \caption{Connexion d'un pilote avec rendu à distance.}
    \label{fig:conn_pilote_seq}
\end{figure}

\begin{figure}[p]
    \centering
    \makeincudegraphics[width=1\textwidth]{classes.png}
    \caption{Diagramme de classes}
    \label{fig:classes}
\end{figure}

\section{Fonctionnalités et descriptif technique}
\subsection{Manager}
Le manager (\texttt{fr.univtln.infomath.dronsim.server.manager.Manager}) est un serveur REST qui gère
les requêtes provenant du client REST du launcher \\(\texttt{fr.univtln.infomath.dronsim.client.launcher.RestClient}).
Lors de mise en place du serveur nous nous sommes posé la question de savoir si nous allions utiliser le framework Quarkus
comme vu en cours ou si il était possible de faire un serveur REST en Java sans framework. Nous avons constaté qu’il était possible d’en créer un à l’aide de Jersey et Grizzly, une solution bien plus légère et plus adaptée à notre problème
car la machine serveur a besoin de ressources pour faire tourner le simulateur et les éventuels rendus graphiques, étant donné que
le cœur de notre application ne repose pas sur une API REST, nous avons donc choisi de ne pas utiliser Quarkus afin d'économiser des ressources
et faciliter la gestion des packages (il aurait probablement fallu faire un repository à part pour le serveur REST utilisant Quarkus).

% TODO: André parler de l'authentification ICI

\subsection{Launcher}
Le \textit{launcher} constitue l'entrée principale du système pour tous les types d'utilisateurs (pilotes, observateurs, maîtres de jeu, administrateurs). Développé en JavaFX, il fournit une interface graphique claire, moderne et ergonomique permettant d'interagir avec le simulateur de manière centralisée.

L'interface GUI du launcher s'adapte dynamiquement au rôle de l'utilisateur identifié après connexion. Celle-ci se fait via un formulaire de login qui interroge le serveur Manager REST. Une fois l'utilisateur authentifié, le GUI propose différentes fonctionnalités selon son profil :
\begin{itemize}
    \item \textbf{Pilote} : l'interface permet de démarrer le client de simulation JMonkeyEngine, qui leur offre un contrôle direct sur le drone qui leur est attribué.
    \item \textbf{Observateur} : sélection d'un drone à suivre (vue embarquée ou externe), ou navigation libre dans la scène.
    \item \textbf{Maître du jeu} : interface complète de gestion (ajout de drones, événements, lancement du serveur de simulation, etc.).
    \item \textbf{Administrateur} : interface de gestion des utilisateurs (liste, ajout, modification, suppression).
\end{itemize}

Le rôle du launcher est aussi comme son nom l'indique de lancer Ardupilot et QGroundControl correctement mais aussi le renderer lorsque
on est en mode rendu local en renseignant automatiquement les paramètres de connexion au simulateur en fonction des réponses qu'il aura obtenu du Manager
lors de la requête de connexion.

\subsection{Serveur JMonkeyEngine}
Le serveur JMonkeyEngine (\texttt{fr.univtln.infomath.dronsim.server.renderer.SimulatorServer}) est le cœur de la simulation.
C'est lui s'occupe de calculer la physique des drones virtuels: à chaque tick serveur il va calculer la nouvelle position de tous les drones en fonction
de la vitesse de chaque moteur, faire évoluer les évènements, gérer les collisions et envoyer les positions de chaque évènement et chaque drone à chaque client connecté
(pilotes et observateurs).

%TODO: Yann parler un peu de la physique ici
Il est important de souligner que l’application des forces dans notre simulation se veut réaliste.
Les forces sont appliquées au niveau de chaque moteur.
Un moteur ne peut changer ni sa position ni sa direction relative au drone auquel il est attaché.
Un moteur ne peut qu'avancer ou reculer.
Donc, pour effectuer un mouvement, le pilote ne peut agir que sur la puissance des moteurs.

\subsection{Client JMonkeyEngine}
Le client JMonkeyEngine (\texttt{fr.univtln.infomath.dronsim.client.renderer.SimulatorClient}) est le composant qui permet de visualiser la simulation. Selon le mode choisi,
il est soit sur la machine serveur (mode cloud) soit sur la machine du pilote (mode local). Il reçoit les positions de chaque drone et chaque évènement à chaque tick serveur
et les mets à jour dans la scène 3D. Il s'occupe aussi de l'affichage de l'eau, de la lumière et des textures mais ne contient aucun élément de physique.
Il va dans les deux modes (local et cloud) capturer chaque frame de la scène 3D et l'envoyer à QGroundControl via un logiciel standard d'encodage vidéo
(Gstreamer) et son implémentation en Java (voir \texttt{fr.univtln.infomath.dronsim.server.simulation.client.FrameCaptureProcessor} et\\
\texttt{fr.univtln.infomath.dronsim.server.utils.GstreamerSender}). À noter qu'il faut que Gstreamer soit installé sur la machine pour
faire fonctionner le client JMonkeyEngine (c'est fait dans le script d'installation fourni).

\section{Scénarios}

\subsection{UC 1 : Recevoir flux vidéo}
\textbf{Prérequis:} Le pilote est connecté au simulateur et la simulation est lancée.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le simulateur envoie un flux vidéo au pilote
    \item Le pilote reçoit et voit le flux vidéo en temps réel
\end{enumerate}

\subsection{UC 2 : Consulter les capteurs}
\textbf{Prérequis:} Le pilote est connecté au simulateur et la simulation est lancée.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le pilote clique sur le bouton "Consulter les capteurs"
    \item Le pilote voit la liste des capteurs avec leurs valeurs en temps réel
\end{enumerate}

\subsubsection*{US 2 : Scénario alternatif : Capteur non disponible}
\begin{enumerate}
    \item[A.2] Le pilote voit la liste des capteurs avec leurs valeurs en temps réel sauf celle du capteur non disponible
\end{enumerate}

\subsection{UC 3 : Suivre un drone}
\textbf{Prérequis:} L'observateur est connecté au simulateur et la simulation est lancée.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item L'observateur clique sur le bouton "Liste des drones connectés"
    \item L'application affiche la liste des drones connectés à la simulation
    \item L'observateur clique sur le bouton "Suivre" du drone qu'il souhaite suivre
    \item L'observateur voit le flux vidéo du drone qu'il suit
\end{enumerate}

\subsubsection*{US 2 : Scénario Exception : Aucun drone connecté}
\begin{enumerate}
    \item[A.1] L'observateur clique sur le bouton "Liste des drones connectés"
    \item[A.2] L'application affiche un message d'erreur indiquant qu'aucun drone n'est connecté à la simulation
\end{enumerate}

\subsection{UC 4 : Changer mode première/troisième personne}
\textbf{Prérequis:} L'observateur est connecté au simulateur, la simulation est lancée et l'observateur suit un drone.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item L'observateur clique sur le bouton "Changer mode première/troisième personne"
    \item L'application change le mode de vue de première personne à troisième personne
\end{enumerate}

\subsubsection*{US 2 : Scénario alternatif}
\begin{enumerate}
    \item[A.2] L'application change le mode de vue de troisième personne à première personne
\end{enumerate}

\subsection{UC 5 : Voir environnement}
\textbf{Prérequis:} L'observateur est connecté au simulateur et la simulation est lancée.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item L'observateur clique sur le bouton "Voir environnement"
    \item L'application affiche l'environnement de la simulation en temps réel
\end{enumerate}

\subsubsection*{US 2 : Scénario alternatif}
\begin{enumerate}
    \item[3.A] L'observateur bouge sa souris pour faire pivoter la caméra
    \item[4.A] L'application affiche l'environnement de la simulation en temps réel avec la nouvelle vue
\end{enumerate}

\subsection{UC 6 : Déplacer la caméra}
\textbf{Prérequis:} L'observateur est connecté au simulateur, la simulation est lancée et l'observateur voit l'environnement.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item L'observateur appuie sur les touches de déplacement pour déplacer la caméra
    \item L'application affiche l'environnement de la simulation en temps réel avec la nouvelle vue
\end{enumerate}

\subsection{UC 7 : Ajouter un drone}
\textbf{Prérequis:} Le maitre de jeu est connecté au simulateur.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le maitre de jeu clique sur le bouton "Ajouter un pilote"
    \item L'application demande au maitre de jeu de choisir le pilote
    \item Le maitre de jeu choisit le pilote
    \item L'application demande au maitre de jeu de choisir le mode de connexion
    \item Le maitre de jeu choisit le mode de connexion "local"
    \item L'application demande au maitre de jeu de choisir le drone attribué au pilote
    \item Le maitre de jeu choisit le drone
    \item L'application affiche un message de confirmation indiquant que le pilote a été ajouté avec succès
\end{enumerate}

\subsubsection*{US 2 : Scénario alternatif}
\begin{enumerate}
    \item[A.5] Le maitre de jeu choisit le mode de connexion "cloud"
    \item[] Le scénario continue en 6.
\end{enumerate}

\subsection{UC 8 : Changer la carte}
\textbf{Prérequis:} Le maitre de jeu est connecté au simulateur et la simulation est lancée.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le maitre de jeu clique sur le bouton "Changer la carte"
    \item L'application demande au maitre de jeu de choisir la nouvelle carte
    \item Le maitre de jeu choisit la nouvelle carte
    \item L'application redémarre la simulation avec la nouvelle carte
\end{enumerate}

\subsection{UC 9 : Gérer les utilisateurs}
\textbf{Prérequis:} L'administrateur est connecté au simulateur.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item L'administrateur clique sur le bouton "Gérer les utilisateurs"
    \item L'application affiche la liste des utilisateurs
    \item L'administrateur clique sur le bouton "Ajouter un utilisateur"
    \item L'application demande à l'administrateur de choisir le type d'utilisateur
    \item L'administrateur choisit le type d'utilisateur
    \item L'application demande à l'administrateur de choisir le nom d'utilisateur
    \item L'administrateur choisit le nom d'utilisateur
    \item L'application affiche un message de confirmation indiquant que l'utilisateur a été ajouté avec succès
\end{enumerate}

\subsubsection*{US 2 : Scénario alternatif}
\begin{enumerate}
    \item[A.3] L'administrateur clique sur le bouton "Supprimer un utilisateur"
    \item[A.4] L'application demande à l'administrateur de choisir l'utilisateur à supprimer
    \item[A.5] L'administrateur choisit l'utilisateur à supprimer
    \item[A.6] L'application affiche un message de confirmation indiquant que l'utilisateur a été supprimé avec succès
\end{enumerate}

\subsubsection*{US 3 : Scénario alternatif}
\textbf{Prérequis :} la simulation est lancée

\begin{enumerate}
    \item[A.4] L'administrateur choisit le nom d'utilisateur
    \item[A.5] L'application affiche les informations de l'utilisateur
    \item[A.6] L'administrateur clique sur le bouton "Exclure l'utilisateur"
    \item[A.7] L'application affiche un message de confirmation indiquant que l'utilisateur a été exclu avec succès
\end{enumerate}

\subsection{UC 10 : Gérer les conditions météo}
\textbf{Prérequis:} Le maitre de jeu accède à l’interface de contrôle de simulation et la simulation est lancée.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le maitre de jeu clique sur le bouton "Conditions météo"
    \item Le système affiche les paramètres modifiables : vent, pluie, luminosité, etc.
    \item Le maitre de jeu ajuste les valeurs via des curseurs ou des champs numériques.
    \item Le maitre de jeu valide la configuration.
    \item Le simulateur applique dynamiquement les nouvelles conditions.
    \item Les drones actifs sont immédiatement soumis à ces contraintes physiques.
\end{enumerate}

\subsection{UC 11 : Gérer les évènements}
\textbf{Prérequis:} Le maitre de jeu accède à l’interface de contrôle de simulation et la simulation est lancée.

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le maitre de jeu clique sur le bouton "consulter événements"
    \item Le système affiche les événements disponibles : obstacle dynamique (comme un poisson, un bateau ou un filet), courant localisé imprévu, perturbation de signal, turbidité de l’eau.
    \item Le maitre de jeu valide et déclenche l’événement.
    \item Le simulateur applique immédiatement l’événement dans l’environnement 3D.
    \item Le drone réagit selon ses algorithmes embarqués (autonomie, retour au point sûr, etc.).
\end{enumerate}

\subsection{UC 12 : Lancer une simulation}
\textbf{Prérequis:}
\begin{itemize}
    \item Le MDJ doit être connecté au simulateur
    \item Le MDJ doit avoir chargé une carte dans le simulateur
\end{itemize}

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le MDJ clique sur le bouton démarrer la simulation
    \item Le Système affiche une fenêtre avec tous les éléments de la simulation (pilote avec drone attitré, carte, liste d'évènements, ...)
    \item Le Système demande d'appuyer sur le bouton "démarrer la simulation"
    \item Le MDJ appuie sur le bouton "démarrer la simulation"
    \item Le système ferme la fenêtre et lance la simulation
\end{enumerate}

\subsubsection*{US 2 : Scénario exception : Le MDJ ne lance pas la simulation}
\begin{enumerate}
    \item[E2.] Le MDJ appuie sur le bouton "Annuler"
    \item[E3.] Le système ferme la fenêtre
\end{enumerate}

\subsection{UC 13 : Piloter Manuellement}
\textbf{Prérequis:}
\begin{itemize}
    \item Le pilote doit posséder un contrôleur configuré
    \item Le pilote doit être dans une simulation avec un drone attitré
\end{itemize}

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item Le Pilote transmet des directives au drone via son contrôleur
    \item Le Système simule le drone en fonction des directives reçues
    \item Retour à l'étape 1
\end{enumerate}

\subsubsection*{US 2 : Scénario alternatif : Le contrôleur utilisé n'est pas reconnu}
\begin{enumerate}
    \item[A2.] Le Système indique au Pilote que l'action n'est pas reconnue
    \item[A3.] Retour à l'étape 1
\end{enumerate}

\subsection{UC 14 : Un utilisateur se connecte}

\subsubsection*{US 1 : Scénario nominal}
\begin{enumerate}
    \item L'utilisateur renseigne nom d'utilisateur/mot de passe
    \item Le lanceur présente à l'utilisateur :
        \begin{itemize}
            \item une liste de drones qui lui appartiennent
            \item les parties qu'il peut observer
        \end{itemize}
    \item L'utilisateur sélectionne un drone
    \item Le lanceur lance l'interface de pilotage
\end{enumerate}

\subsubsection*{US 1 : Scénario alternatif : L'utilisateur observe}
\begin{enumerate}
    \item L'utilisateur renseigne nom d'utilisateur/mot de passe
    \item Le lanceur présente à l'utilisateur :
        \begin{itemize}
            \item une liste de drones qui lui appartiennent
            \item les parties qu'il peut observer
        \end{itemize}
    \item L'utilisateur sélectionne une partie
    \item Le lanceur lance l'interface d'observation
\end{enumerate}

\subsubsection*{US 1 : Scénario alternatif : L'utilisateur peut être MDJ}
\begin{enumerate}
    \item L'utilisateur renseigne nom d'utilisateur/mot de passe
    \item Le lanceur présente à l'utilisateur :
        \begin{itemize}
            \item une liste de drones qui lui appartiennent
            \item les parties qu'il peut observer
            \item un bouton "démarrer partie"
        \end{itemize}
    \item L'utilisateur démarre une partie
    \item Le lanceur lance l'interface de gestion de partie avec une partie lancée
\end{enumerate}

\section{Organisation du projet}

Le projet s'est déroulé en six sprints d'une semaine chacun. Les deux premiers sprints ont eu considérablement moins
d'heures dédiées au projet que les 4 derniers sprints à cause de cours et d'examens qui se sont placés à ce moment là.
Le premier sprint à été consacré à de la recherche et de la documentation principalement sur le fonctionnement et l'installation d'Ardupilot, QGroundControl,
la compréhension du protocole MAVLink, de la recherche sur la mise en place d'une application client-serveur avec JMonkeyEngine,
le streaming vidéo avec Gstreamer et l'aspect sécurité de notre future application. Pour procéder nous nous sommes répartis les tâches, chacun faisant ses recherches
sur un ou deux sujet en particulier et en partageant les connaissances acquises au fur et à mesure avec le reste du groupe.
Concernant la recherche en elle même nous nous sommes grandement aidé de LLM comme ChatGPT et Copilot afin de nous donner des pistes de recherche et de
nous aider à comprendre certains concepts et comment les différents composants allaient fonctionner ensemble, mais bien évidemment il a fallu se méfier
des fausses informations et des incohérences que peuvent produire ces outils. C'est pour cela qu'il est important d'aller vérifier toutes les informations
obtenues par ces outils et de les croiser avec d'autres sources comme les documentations officielles.
Malgré tout, ces outils nous ont été d'une grande aide pour la recherche et la compréhension de certains concepts et composants de notre future application.\\

Le second sprint, lui aussi écourté par les examens, a été aux dernières recherches et à la modélisation. Nous avons mis au point
une première version des diagrammes que vous avez vu précédemment, ainsi que les différents scénarios et enfin le backlog.
À partir de ce moment là l'organisation fut la suivante : le lundi matin était consacré à la finition du sprint en cours
et à la mise en commun du travail effectué par chacun dans la mesure du possible, puis l'après-midi était réservé à la mise en place du nouveau sprint : on regardait les
user stories du backlog, on séparait celles qui étaient conséquentes en plusieurs tâches qu'on chiffrait en nombre d'heures et qu'on se répartissait en fonction des
préférences de chacun. La version finale du backlog est disponible à cette adresse : \href{https://docs.google.com/spreadsheets/d/1_9b835ZHfRBKW2wKLp_8N-aMPw3WcvQoGiQM7r9oeu4/edit?usp=sharing}{Backlog Google Sheets}.
Concernant le versionage du code, nous avons utilisé GitHub, chaque membre avait au moins une branche sur laquelle il développait sa fonctionnalité et à la fin d'un sprint lorsque c'était possible ou
pendant le sprint lorsque c'était nécessaire, nous faisions des merge sur la branche dev qui était réservée à la mise en commun du travail de chacun.\\

Le troisième sprint (noté sprint 1 dans le backlog) a marqué le début du développement. Durant ce sprint nous avons commencé la mise en place du serveur JMonkeyEngine et sa connexion avec un client,
géré le streaming vidéo avec Gstreamer, initialisé un environnement JMonkeyEngine qui fonctionne entièrement en local afin de pouvoir effectuer des tests sans avoir à gérer le côté client/serveur,
et nous avons essayé d'établir une première connexion entre QGroundControl, Ardupilot et un programme Java de test.\\

Durant le quatrième sprint (noté sprint 2 dans le backlog), nous avons continué le développement du client/serveur JMonkeyEngine, nous avons mis au point le GUI du launcher,
nous nous sommes mis d'accord sur l'interface Controleur qu'il allait falloir implémenter et commencé l'implémentation Controleur Ardupilot. La fin du sprint marquait la moitié du développement de l'application,
le projet étant dans un état convenable, nous avons fait un premier merge sur la branche master et fait un premier tag appelé 0.0.1 .\\

Le cinquième sprint (noté sprint 3 dans le backlog) a été consacré à mise en place de la bibliothèque Geotools dans le controleur Ardusub afin de gérer le GPS, la mise en place du serveur REST (Manager) ainsi que de son client
et de le mettre en lien avec le GUI du launcher, la mise en place de l'authentification des utilisateurs et la gestion des rôles (pilote, MDJ, observateur, administrateur) ainsi que la gestion des drones virtuels. On a aussi commencé
à travailler sur la gestion des évènements dans le simulateur. Nous avons aussi à ce moment là mis en place un script d'installation afin de faciliter l'installation des
différents composants qui était fastidieuse à faire à la main.\\

Au début du cinquième sprint nous avions prévu pour le sixième de mettre en place les protocoles de crypto pour sécuriser les échanges entre Ardupilot et le simulateur ainsi qu'un
chiffrement/déchiffrement des flux vidéo, mais nous avons rapidement réalisé que nous n'aurions pas le temps de le faire correctement et qu'il nous aurait fallu une à deux semaines de plus pour le faire (voir la section \ref{sec:perspectives}).
C'est pourquoi nous avons décidé de mettre cette aspect de côté pour se concentrer sur finir proprement tout ce qui avait été commencé comme la physique (voir la section \ref{sec:problemes}) et l'implémentation
des évènements sur le serveur et de l'authentification et bien évidemment faire de la correction de bugs générale et à la fin du sprint nous avons mis à jour la branche master et fait un tag 0.1.0 . Nous avons aussi écrit la documentation du projet et préparé la présentation du projet pour la soutenance.


\section{Problèmes rencontrés}
\label{sec:problemes}
%Yann et André : parler de la physique et du controler Ardupilot et autres problèmes ici
Durant le déroulement du projet, nous avons rencontré beaucoup de problèmes qui ont ralenti et perturbé son bon déroulement.
Certains de ces problèmes nous ont ralenti dans la progression du projet.
Ces ralentissements nous ont forcé à abandonner certains aspects du projet, comme la cryptographie.

\subsection{Contraintes de temps}
Tout d'abord, il y a eu la contrainte temporelle pour réaliser le projet.
En tout, nous avons eu cinq semaines pour le mener à bien.
À cause des jours fériés et des ponts, trois de ces semaines ont été réduites à trois jours au lieu de cinq.
Des cours et examens se sont greffés aux deux premières semaines du projet.

\subsection{Un domaine inconnu}
La plupart des problèmes rencontrés sont dus à notre difficulté à trouver de l'information.
Ce projet est notre tout premier travail où la recherche d'information a une telle importance et prend autant de temps.
Au début du projet, nous n'avions quasiment aucune connaissance dans le domaine de la simulation de drone.
Aucun d'entre nous n'avait entendu parler d'Ardupilot ou d'Ardusub.
Nous ne savions pas ce que c'était, ce que ça faisait, et encore moins comment l'utiliser dans le cadre de notre projet.
Plus on en apprenait sur Ardupilot, plus les sujets de recherche se multipliaient :
\begin{itemize}
    \item Le protocole MavLink, qui est le protocole de communication utilisé par Ardupilot.
    \item QGroundControl, l'application de contrôle de drone recommandée avec Ardupilot.
    \item Le Software In The Loop (SITL), qui est le cœur de la simulation d'Ardupilot.
\end{itemize}
À cause des jours fériés, des cours et des examens, il nous a fallu deux semaines pour avoir une compréhension générale de tous ces sujets.

\subsection{Simulateur d'Ardupilot et simulateur du projet}
Le premier sujet de recherche bloquant était de pouvoir faire fonctionner Ardupilot avec la simulation de notre serveur.
Nous nous sommes donc mis à chercher plusieurs pistes.
Tout d'abord, nous avons cherché à savoir comment Ardupilot et QGroundControl interagissent ensemble.
En découvrant qu'ils communiquent avec le protocole Mavlink, nous avons donc fait des recherches pour savoir comment l'utiliser avec notre serveur.
Il nous a fallu, tout d'abord, trouver une bibliothèque pour pouvoir lire et écrire des messages Mavlink avec Java.
Après quelques recherches, il nous a semblé que Mavlink a été pensé pour être utilisé avec les langages Python ou C.
Les bibliothèques Java officielles de Mavlink s’installent avec Gradle par défaut, alors que nous avons appris à utiliser Maven.
Nous avons finalement réussi à installer la bibliothèque Dronefleet avec Maven.
Une fois installée, nous avons remarqué que les méthodes UDP de Java n'étaient pas compatibles avec Dronefleet.
Or, Ardupilot utilise des connexions UDP de base.
Nous avons finalement réussi à faire en sorte qu'Ardupilot utilise une connexion TCP.
Il était aussi possible de créer des méthodes en Java pour pallier le problème, mais par manque de temps, nous nous sommes abstenus.

Durant les tests, nous avons rapidement été capables de récupérer la puissance des moteurs.
Cependant, nous avons bloqué sur la façon de forcer une position à Ardupilot.
Comme dit plus tôt, Ardupilot a sa propre simulation.
Mais cette simulation ne connaît pas notre terrain et ne possède aucune gestion d'obstacle ou de perturbation comme les courants marins.
D'où l'importance de pouvoir forcer les positions.

Comme après plusieurs jours aucune solution n'a été trouvée, nous avons cherché plusieurs autres pistes.
Nous avons appris que le SITL d’Ardupilot était fait pour être réécrit.
Il s'agit d'une façon plus propre que de passer par des paquets Mavlink.
Finalement, grâce à la découverte du problème de position avec Mavlink, et à cause du temps restant pour finir le projet, nous sommes restés sur les échanges Mavlink.

L’inconvénient est qu’à part la position, nous n’avons pas réussi à réécrire d’autres informations,
comme par exemple l’orientation ou l’inclinaison du drone.
Nous n’avons pas eu le temps d’implémenter la transmission de données de capteurs comme le compas ou le baromètre.

\subsection{La physique}
Le deuxième sujet de recherche bloquant était la physique du drone.
Plus précisément, nous avons eu du mal à appliquer de manière réaliste les forces pour chaque moteur.
À cause de la mauvaise documentation de certaines méthodes clés, il nous a fallu six jours pour régler ce problème.
Si la documentation avait été correctement remplie, nous aurions pu finir la physique en deux ou trois jours.
La physique fut mise en place le dernier jour de développement du projet.
Sans le temps perdu, il aurait été possible de s'occuper de la partie cryptographie.


\section{Perspectives d'évolution et Conclusion}
\label{sec:perspectives}

% André Parler sécurité ici

Pour conclure, le projet était très intéressant à mener, il nous a appris beaucoup de choses et nous a permis d'avoir un avant
goût du travail d'équipe en entreprise. Le projet est plutôt réussi dans l'ensemble mais je pense qu'il faut plutôt le voir comme une base solide
d'un simulateur qui pourrait être bien plus ambitieux. Si le projet devait être poursuivi, les premiers éléments à régler seraient
l'utilisation des classes prévues pour les capteurs et autres modules car pour l'instant elles ne le sont pas, il faudrait aussi
rajouter de la sécurité dans les échanges réseau et terminer l'implémentation de l'administrateur.\\
Pour un cycle de vie à long terme avec des mises à jour régulières, on pourrait imaginer rajouter des modèles de drones,
rajouter plusieurs environnements différents, ajouter des évènements plus complexes, rajouter des systèmes comme des bras robotisés,
supporter les manettes de jeu pour le controleur Ardupilot, proposer différentes caméra différentes (grand angle, thermique, etc.) et bien sûr
rajouter des fonctionnalités pour les pilotes et les MDJ comme la possibilité de créer des missions.
Pour revenir sur la problématique initiale, une fois tout ceci mis en place le simulateur pourrait être utilisé afin d'entrainer des pilotes et des IA à effectuer
des missions sous-marines dans un environnement virtuel avant de les envoyer sur le terrain, ce qui permettrait de réduire les coûts et
d'augmenter la sécurité des missions. Il pourrait aussi être utilisé pour faire de la recherche sur les drones sous-marins et leur comportement dans différents environnements.

\end{document}
